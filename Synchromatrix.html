<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Horizontal Calendar</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    input[type="file"], input[type="range"], button { margin-bottom: 10px; }
    #calendarWrapper {
      overflow-x: auto;
      border: 1px solid #ccc;
    }
    .timeline {
      display: grid;
      grid-template-columns: 150px repeat(24, var(--hour-width, 60px));
      min-width: calc(150px + 24 * var(--hour-width, 60px));
      border-bottom: 1px solid #ccc;
      position: relative;
    }
    .header {
      font-weight: bold;
      text-align: center;
      border-right: 1px solid #ccc;
      padding: 2px;
    }
    .label {
      border-right: 1px solid #ccc;
      padding: 2px;
      background: #f0f0f0;
    }
    .label.group { cursor: pointer; user-select: none; }
    .cell {
      border: 1px solid #eee;
      height: 40px;
      position: relative;
    }
    .event {
      position: absolute;
      top: 4px;
      bottom: 4px;
      border-radius: 4px;
      color: white;
      font-size: 12px;
      padding: 2px 4px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: grab;
    }
    .event:active { cursor: grabbing; }
    .resize-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 6px;
      cursor: ew-resize;
    }
    .resize-handle.left { left: 0; }
    .resize-handle.right { right: 0; }

    /* Modal styles for Teilnehmer-Verwaltung */
    .modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.45); z-index: 1000; }
    .modal.open { display: flex; }
    .modal .dialog { background: #fff; width: min(900px, 95vw); max-height: 90vh; border-radius: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.25); display: flex; flex-direction: column; overflow: hidden; }
    .modal .dialog header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #eee; background: #fafafa; }
    .modal .dialog header h3 { margin: 0; font-size: 16px; }
    .modal .dialog header button { border: none; background: transparent; font-size: 22px; line-height: 1; cursor: pointer; padding: 4px 8px; }
    .modal .dialog .body { padding: 12px 16px; overflow: auto; }
    .gm-toolbar { display: grid; gap: 10px; margin-bottom: 10px; }
    .gm-section { padding: 6px 0; border-top: 1px solid #eee; }
    .gm-row { display: flex; align-items: center; gap: 8px; padding: 2px 0; }
    .gm-name { min-width: 160px; }
    .gm-header { display: flex; align-items: center; justify-content: space-between; margin: 2px 0 6px; }
    .gm-header .gm-actions { display: flex; gap: 6px; }
    .gm-toolbar { background: #fafafa; border: 1px solid #eee; border-radius: 8px; padding: 10px; }
    .gm-toolbar input[type="text"] { padding: 6px 8px; }
    .gm-toolbar select, .gm-toolbar button { padding: 6px 8px; }
    .gm-toolbar .row { display: grid; grid-template-columns: 180px 1fr 1fr auto; align-items: center; gap: 8px; }
    .gm-toolbar .row input[type="text"], .gm-toolbar .row select { width: 100%; }
    .gm-card { border: 2px solid #eee; border-radius: 10px; padding: 10px; margin: 10px 0; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.04); }
    .gm-card .gm-head { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
    .gm-card .gm-title { font-weight: 600; cursor: pointer; user-select: none; display: inline-flex; align-items: center; gap: 8px; }
    .gm-search { display: flex; gap: 8px; align-items: center; }
    .gm-search input[type="text"] { flex: 1; padding: 6px 8px; }
    .gm-toolbar { display: grid; gap: 8px; }
    .gm-toolbar .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .gm-toolbar .section-title { font-weight: 600; margin-right: 6px; }
    .gm-people { display: flex; flex-direction: column; gap: 6px; }
    .gm-chip { display: flex; align-items: center; gap: 6px; padding: 4px 8px; border: 1px solid #e0e0e0; border-radius: 10px; background: #f8f8f8; width: 100%; justify-content: space-between; min-height: 36px; }
    .gm-chip .gm-chip-name { max-width: 60%; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; margin-left: 10px; }
    .gm-chip .gm-chip-actions { display: inline-flex; gap: 8px; margin-left: auto; align-items: center; }
    .gm-chip .gm-chip-actions select { height: 28px; line-height: normal; vertical-align: middle; }
    .gm-chip .gm-del { width: 28px; height: 28px; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 16px; line-height: 1; border: 1px solid #ddd; border-radius: 6px; background: #fff; cursor: pointer; }
    .gm-chip .gm-chip-actions .gm-del { align-self: center; }
    /* Event editor */
    .ev-dt { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; grid-column: 1 / span 2; }
    .ev-dt .ev-block { display: flex; align-items: center; gap: 8px; padding: 8px 10px; border: 1px solid #eee; border-radius: 8px; background: #fafafa; }
    .ev-dt .ev-head { font-weight: 600; min-width: 70px; color: #333; }
    .ev-dt input[type="date"], .ev-dt input[type="time"] { padding: 4px 6px; }
    /* No-attendees list */
    .na-list { display: grid; grid-template-columns: 1fr 140px 140px auto; gap: 8px 12px; align-items: center; }
    .na-head { font-weight: 600; color: #444; }
    .na-pill { display: inline-block; width: 12px; height: 12px; border-radius: 999px; border: 1px solid #ccc; margin-right: 6px; vertical-align: middle; }
    .na-row { display: contents; }
    /* Top actions layout */
    .actions-row { display: flex; justify-content: space-between; align-items: center; margin: 8px 0; }
    .mgmt-row { margin: 10px 0 0; }
  </style>
</head>
<body>
  <h1>Interactive Horizontal Calendar</h1>
  <p>
    <label for="fileInput">Select JSON file:</label>
    <input type="file" id="fileInput" accept=".json">
    <button id="downloadBtn" disabled>Download Updated JSON</button>
  </p>
  <p class="actions-row">
    <button id="newEventBtn" disabled>Neuer Termin</button>
    <button id="noAttBtn" disabled>Termine ohne Teilnehmer</button>
  </p>
  <p class="mgmt-row">
    <button id="manageBtn" disabled>Teilnehmer und Gruppenverwaltung</button>
  </p>
  <p>
    Zoom: <input type="range" id="zoomSlider" min="30" max="200" value="60">
  </p>
  <!-- Teilnehmer-Verwaltung Modal -->
  <div id="gmModal" class="modal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="gmModalTitle">
      <header>
        <h3 id="gmModalTitle">Teilnehmer-Verwaltung</h3>
        <button id="gmModalClose" aria-label="Schließen">×</button>
      </header>
      <div id="gmModalBody" class="body"></div>
    </div>
  </div>
  <!-- Termin-Editor Modal -->
  <div id="evModal" class="modal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="evModalTitle">
      <header>
        <h3 id="evModalTitle">Termin</h3>
        <button id="evModalClose" aria-label="Schließen">×</button>
      </header>
      <div id="evModalBody" class="body"></div>
    </div>
  </div>
  <!-- Termine ohne Teilnehmer Modal -->
  <div id="naModal" class="modal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="naModalTitle">
      <header>
        <h3 id="naModalTitle">Termine ohne Teilnehmer</h3>
        <button id="naModalClose" aria-label="Schließen">×</button>
      </header>
      <div id="naModalBody" class="body"></div>
    </div>
  </div>
  <div id="calendarWrapper">
    <div id="calendar"></div>
  </div>

  <script>
    let tableData;
    let hourWidth = 60; // px per hour
    // Teilnehmer-Verwaltung UI state
    let gmCollapsed = new Set();
    let gmSearchTerm = "";
    let collapsedGroups = new Set();

    // ---- Farben für Gruppen ----
    const GROUP_COLOR_PALETTE = [
      "#64b5f6", "#81c784", "#ffd54f", "#ba68c8",
      "#4db6ac", "#ff8a65", "#90a4ae", "#e57373"
    ];
    function hexToRgb(hex) {
      if (!hex) return { r: 153, g: 153, b: 153 };
      let h = hex.replace('#','').trim();
      if (h.length === 3) h = h.split('').map(c => c + c).join('');
      const int = parseInt(h, 16);
      return { r: (int >> 16) & 255, g: (int >> 8) & 255, b: int & 255 };
    }
    function rgba(rgb, a) {
      const { r, g, b } = rgb || { r: 153, g: 153, b: 153 };
      return `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    function findGroupByName(name) {
      return (tableData?.groups || []).find(g => g.name === name);
    }
    function ensureGroupColor(g, idx = 0) {
      if (!g) return '#999999';
      if (!g.color) {
        // deterministisch: Verwende Index in Liste für Farbwahl
        const i = Math.max(0, (idx || tableData.groups.indexOf(g))) % GROUP_COLOR_PALETTE.length;
        g.color = GROUP_COLOR_PALETTE[i];
      }
      return g.color;
    }
    function getGroupColorByName(name) {
      if (name === 'Ungruppiert') return '#9e9e9e';
      const g = findGroupByName(name);
      return ensureGroupColor(g);
    }

    // ---- Teilnehmer-Verwaltung (Gruppen & Personen) ----
    function renderGroupManager() {
      const gm = document.getElementById("gmModalBody");
      if (!tableData || !Array.isArray(tableData.groups)) {
        gm.innerHTML = "";
        return;
      }

      // Helpers
      const groupNames = () => tableData.groups.map(g => g.name);
      const findGroup = (name) => tableData.groups.find(g => g.name === name);
      const personExists = (name) => tableData.groups.some(g => (g.people||[]).includes(name));

      const groupExists = (name) => {
        if (!name) return false;
        const n = String(name).trim().toLowerCase();
        return groupNames().some(g => g.toLowerCase() === n);
      };

      function ensureUngrouped() {
        let u = findGroup("Ungruppiert");
        if (!u) {
          u = { name: "Ungruppiert", people: [] };
          tableData.groups.push(u);
        }
        if (!Array.isArray(u.people)) u.people = [];
        return u;
      }

      function addGroup(name) {
        const n = (name || "").trim();
        if (!n) { alert("Gruppenname darf nicht leer sein."); return; }
        if (groupExists(n)) { alert("Gruppe existiert bereits."); return; }
        const idx = tableData.groups.length;
        const color = GROUP_COLOR_PALETTE[idx % GROUP_COLOR_PALETTE.length];
        tableData.groups.push({ name: n, people: [], color });
        loadCalendar(tableData);
        updateNoAttCount();
        renderGroupManager();
      }

      function deleteGroup(name) {
        if (name === "Ungruppiert") { alert("Die Gruppe 'Ungruppiert' kann nicht gelöscht werden."); return; }
        const g = findGroup(name);
        if (!g) return;
        if (!confirm(`Gruppe "${name}" löschen? Mitglieder werden nach 'Ungruppiert' verschoben.`)) return;
        const fallback = ensureUngrouped();
        (g.people || []).forEach(p => {
          if (!fallback.people.includes(p)) fallback.people.push(p);
        });
        // Entferne Gruppenname aus allen Events
        (tableData.events || []).forEach(ev => {
          if (Array.isArray(ev.attendees)) {
            ev.attendees = ev.attendees.filter(a => a !== name);
          }
        });
        // Entferne Gruppe
        tableData.groups = tableData.groups.filter(gr => gr.name !== name);
        loadCalendar(tableData);
        updateNoAttCount();
        renderGroupManager();
      }

      function addPersonToGroup(name, groupName) {
        const n = (name || "").trim();
        if (!n) { alert("Name darf nicht leer sein."); return; }
        if (!groupNames().includes(groupName)) { alert("Gruppe nicht gefunden."); return; }
        if (personExists(n)) { alert("Teilnehmername bereits vorhanden."); return; }
        const g = findGroup(groupName);
        if (!Array.isArray(g.people)) g.people = [];
        g.people.push(n);
        loadCalendar(tableData);
        updateNoAttCount();
        renderGroupManager();
      }

      function movePerson(name, fromGroup, toGroup) {
        if (fromGroup === toGroup) return;
        const src = findGroup(fromGroup);
        const dst = findGroup(toGroup);
        if (!src || !dst) return;
        src.people = (src.people||[]).filter(p => p !== name);
        if (!Array.isArray(dst.people)) dst.people = [];
        if (dst.people.includes(name)) { alert("Zielgruppe enthält den Namen bereits."); return; }
        dst.people.push(name);
        loadCalendar(tableData);
        updateNoAttCount();
        renderGroupManager();
      }

      function deletePerson(name) {
        // Entferne aus allen Gruppen
        tableData.groups.forEach(g => {
          g.people = (g.people||[]).filter(p => p !== name);
        });
        // Entferne aus allen Events
        (tableData.events||[]).forEach(ev => {
          if (Array.isArray(ev.attendees)) {
            ev.attendees = ev.attendees.filter(a => a !== name);
          }
        });
        loadCalendar(tableData);
        renderGroupManager();
      }

      // Aufbau UI
      gm.innerHTML = "";

      const addWrap = document.createElement("div");
      addWrap.className = "gm-toolbar";
      // Suche & globales Ein-/Ausklappen
      const gmSearch = document.createElement("div");
      gmSearch.className = "gm-search";
      const gmSearchInput = document.createElement("input");
      gmSearchInput.type = "text"; gmSearchInput.placeholder = "Suchen (Gruppen/Teilnehmer)"; gmSearchInput.value = gmSearchTerm || "";
      gmSearchInput.addEventListener("input", () => { gmSearchTerm = (gmSearchInput.value || "").trim().toLowerCase(); renderList(); });
      const gmCollapseAll = document.createElement("button"); gmCollapseAll.textContent = "Alle einklappen";
      gmCollapseAll.addEventListener("click", () => { gmCollapsed = new Set(tableData.groups.map(g => g.name)); renderList(); });
      const gmExpandAll = document.createElement("button"); gmExpandAll.textContent = "Alle ausklappen";
      gmExpandAll.addEventListener("click", () => { gmCollapsed = new Set(); renderList(); });
      gmSearch.appendChild(gmSearchInput); gmSearch.appendChild(gmCollapseAll); gmSearch.appendChild(gmExpandAll);
      addWrap.appendChild(gmSearch);

      const groupSelect = document.createElement("select");
      groupSelect.id = "gmAddGroup";
      groupNames().forEach(n => {
        const opt = document.createElement("option");
        opt.value = opt.textContent = n;
        groupSelect.appendChild(opt);
      });

      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.placeholder = "Name des Teilnehmers";
      nameInput.id = "gmAddName";

      const addBtn = document.createElement("button");
      addBtn.textContent = "Hinzufügen";
      addBtn.addEventListener("click", () => addPersonToGroup(nameInput.value, groupSelect.value));
      addBtn.textContent = "Hinzufügen";

      const rowAddPerson = document.createElement("div"); rowAddPerson.className = "row";
      const secTitle1 = document.createElement("span"); secTitle1.className = "section-title"; secTitle1.textContent = "Teilnehmer hinzufügen";
      // Korrigiere Button-Text (Encoding)
      secTitle1.textContent = "Teilnehmer hinzufügen";
      addBtn.textContent = "Hinzufügen";
      addBtn.textContent = "Hinzufügen";
      rowAddPerson.appendChild(secTitle1);
      // Normalize label text with proper umlauts
      secTitle1.textContent = "Teilnehmer hinzufügen";
      // Ensure correct button label text
      addBtn.textContent = "Hinzufügen";
      rowAddPerson.appendChild(nameInput);
      rowAddPerson.appendChild(groupSelect);
      rowAddPerson.appendChild(addBtn);
      addWrap.appendChild(rowAddPerson);

      // Gruppe hinzufügen
      const gNameInput = document.createElement("input");
      gNameInput.type = "text";
      gNameInput.placeholder = "Gruppenname";
      gNameInput.id = "gmGroupName";

      const gAddBtn = document.createElement("button");
      gAddBtn.textContent = "Gruppe hinzufügen";
      gAddBtn.addEventListener("click", () => addGroup(gNameInput.value));
      gAddBtn.textContent = "Gruppe hinzufügen";

      const rowAddGroup = document.createElement("div"); rowAddGroup.className = "row";
      const secTitle2 = document.createElement("span"); secTitle2.className = "section-title"; secTitle2.textContent = "Gruppe hinzufügen";
      gAddBtn.textContent = "Gruppe hinzufügen";
      rowAddGroup.appendChild(secTitle2);
      secTitle2.textContent = "Gruppe hinzufügen";
      // Encoding fix for secTitle2
      secTitle2.textContent = "Gruppe hinzufügen";
      rowAddGroup.appendChild(gNameInput);
      // spacer removed to reduce left gap
      // Ensure correct label text
      gAddBtn.textContent = "Gruppe hinzufügen";
      rowAddGroup.appendChild(gAddBtn);
      addWrap.appendChild(rowAddGroup);

      gm.appendChild(addWrap);

      // Neue Listen-Render-Funktion (verhindert Fokusverlust beim Suchen)
      function renderList() {
        let listWrap = document.getElementById("gmListWrap");
        if (!listWrap) {
          listWrap = document.createElement("div");
          listWrap.id = "gmListWrap";
          listWrap.style.marginTop = "10px";
          gm.appendChild(listWrap);
        }
        listWrap.innerHTML = "";

        tableData.groups.forEach(g => {
          // Blende 'Ungruppiert' aus, wenn leer
          if ((g.name === 'Ungruppiert') && (!g.people || g.people.length === 0)) return;
          const term = (gmSearchTerm || "").toLowerCase();
          const peopleList = (g.people || []);
          const peopleFiltered = term ? peopleList.filter(p => p.toLowerCase().includes(term)) : peopleList;
          const groupMatches = !term || g.name.toLowerCase().includes(term) || peopleFiltered.length > 0;
          if (!groupMatches) return;
          const section = document.createElement("div");
          section.className = "gm-card";
          // Rahmenfarbe = Gruppenfarbe
          try { section.style.borderColor = ensureGroupColor(g); } catch(e) {}

          const header = document.createElement("div");
          header.className = "gm-head";
          header.style.fontWeight = "bold";
          // Titel mit Einklapp-Pfeil
          const title = document.createElement("div");
          title.className = "gm-title";
          const isCollapsed = gmCollapsed.has(g.name);
          title.textContent = (isCollapsed ? "> " : "v ") + `${g.name} (${(g.people||[]).length})`;
          title.addEventListener('click', () => {
            if (gmCollapsed.has(g.name)) gmCollapsed.delete(g.name); else gmCollapsed.add(g.name);
            renderList();
          });
          header.appendChild(title);
          section.appendChild(header);
          // Header-Aktionen (Gruppe löschen)
          header.style.display = "flex";
          header.style.alignItems = "center";
          header.style.justifyContent = "space-between";
          const hActions = document.createElement("div");
          // Farbwähler direkt neben dem Titel
          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.value = ensureGroupColor(g);
          colorInput.title = "Gruppenfarbe";
          colorInput.addEventListener("input", () => {
            g.color = colorInput.value;
            loadCalendar(tableData);
            renderList();
          });
          title.appendChild(colorInput);
          // Umbenennen-Button
          const renameBtn = document.createElement("button");
          renameBtn.textContent = "Umbenennen";
          renameBtn.addEventListener("click", () => {
            const oldName = g.name;
            const input = prompt("Neuer Gruppenname:", oldName);
            if (input == null) return; // canceled
            const newName = String(input).trim();
            if (!newName || newName === oldName) return;
            if ((tableData.groups || []).some(gr => gr !== g && (gr.name||"").toLowerCase() === newName.toLowerCase())) {
              alert("Gruppe existiert bereits.");
              return;
            }
            // Update group name
            g.name = newName;
            // Update attendees in all events
            (tableData.events || []).forEach(ev => {
              if (Array.isArray(ev.attendees)) {
                ev.attendees = ev.attendees.map(a => a === oldName ? newName : a);
              }
            });
            // Preserve collapsed state
            if (gmCollapsed && gmCollapsed.has(oldName)) { gmCollapsed.delete(oldName); gmCollapsed.add(newName); }
            if (typeof collapsedGroups !== 'undefined' && collapsedGroups instanceof Set && collapsedGroups.has(oldName)) {
              collapsedGroups.delete(oldName); collapsedGroups.add(newName);
            }
            // Update toolbar group select options without full re-render
            const gs = document.getElementById("gmAddGroup");
            if (gs) {
              const prev = gs.value;
              gs.innerHTML = "";
              (tableData.groups || []).forEach(gr => { const opt = document.createElement("option"); opt.value = opt.textContent = gr.name; gs.appendChild(opt); });
              gs.value = (prev === oldName) ? newName : prev;
            }
            // Re-render list and calendar
            loadCalendar(tableData);
            renderList();
          });
          hActions.appendChild(renameBtn);
          if (g.name !== "Ungruppiert") {
            const delGroupBtn = document.createElement("button");
            delGroupBtn.textContent = "Gruppe löschen";
            delGroupBtn.addEventListener("click", () => deleteGroup(g.name));
            hActions.appendChild(delGroupBtn);
          }
          header.appendChild(hActions);

          if (!gmCollapsed.has(g.name)) {
            ( (gmSearchTerm ? (g.people||[]).filter(p => p.toLowerCase().includes((gmSearchTerm||"").toLowerCase())) : (g.people||[])) ).forEach(p => {
              const row = document.createElement("div");
              row.className = "gm-chip";
              row.style.display = "flex";
              row.style.alignItems = "center";
              row.style.gap = "8px";
              row.style.padding = "2px 0";

              const name = document.createElement("span");
              name.textContent = p;
              name.style.minWidth = "160px";
              name.className = "gm-chip-name";

              const moveSel = document.createElement("select");
              groupNames().forEach(n => {
                const opt = document.createElement("option");
                opt.value = opt.textContent = n;
                if (n === g.name) opt.selected = true;
                moveSel.appendChild(opt);
              });
              moveSel.addEventListener("change", () => movePerson(p, g.name, moveSel.value));

              const delBtn = document.createElement("button");
              delBtn.className = "gm-del";
              delBtn.textContent = "✕";
              delBtn.addEventListener("click", () => {
                if (confirm(`"${p}" wirklich löschen?`)) deletePerson(p);
              });

              row.appendChild(name);
              // Aktionen: verschieben + löschen
              const actions = document.createElement("span");
              actions.className = "gm-chip-actions";
              actions.appendChild(moveSel);
              actions.appendChild(delBtn);
              row.appendChild(actions);
              section.appendChild(row);
            });
          }

          listWrap.appendChild(section);
        });
      }

      // initiale Liste
      renderList();
      return;

      const listWrap = document.createElement("div");
      listWrap.style.marginTop = "10px";

      tableData.groups.forEach(g => {
        const term = (gmSearchTerm || "").toLowerCase();
        const peopleList = (g.people || []);
        const peopleFiltered = term ? peopleList.filter(p => p.toLowerCase().includes(term)) : peopleList;
        const groupMatches = !term || g.name.toLowerCase().includes(term) || peopleFiltered.length > 0;
        if (!groupMatches) return;
        const section = document.createElement("div");
        section.className = "gm-card";
        try { section.style.borderColor = ensureGroupColor(g); } catch(e) {}

        const header = document.createElement("div");
        header.className = "gm-head";
        header.style.fontWeight = "bold";
        // Titel mit Einklapp-Pfeil
        const title = document.createElement("div");
        title.className = "gm-title";
        const isCollapsed = gmCollapsed.has(g.name);
        title.textContent = (isCollapsed ? "> " : "v ") + `${g.name} (${(g.people||[]).length})`;
        title.addEventListener('click', () => {
          if (gmCollapsed.has(g.name)) gmCollapsed.delete(g.name); else gmCollapsed.add(g.name);
          renderGroupManager();
        });
        header.appendChild(title);
        section.appendChild(header);
        // Header-Aktionen (Gruppe löschen)
        header.style.display = "flex";
        header.style.alignItems = "center";
        header.style.justifyContent = "space-between";
        const hActions = document.createElement("div");
        // Farbwähler
        const colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.value = ensureGroupColor(g);
        colorInput.title = "Gruppenfarbe";
        colorInput.addEventListener("input", () => {
          g.color = colorInput.value;
          loadCalendar(tableData);
          renderGroupManager();
        });
        // Farbeingabe direkt neben dem Titel
        title.appendChild(colorInput);
        if (g.name !== "Ungruppiert") {
          const delGroupBtn = document.createElement("button");
          delGroupBtn.textContent = "Gruppe löschen";
          delGroupBtn.addEventListener("click", () => deleteGroup(g.name));
          hActions.appendChild(delGroupBtn);
        }
        header.appendChild(hActions);

        if (!gmCollapsed.has(g.name)) {
        ( (gmSearchTerm ? (g.people||[]).filter(p => p.toLowerCase().includes((gmSearchTerm||"").toLowerCase())) : (g.people||[])) ).forEach(p => {
          const row = document.createElement("div");
          row.className = "gm-chip";
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          row.style.padding = "2px 0";

          const name = document.createElement("span");
          name.textContent = p;
          name.style.minWidth = "160px";
          name.className = "gm-chip-name";

          const moveSel = document.createElement("select");
          groupNames().forEach(n => {
            const opt = document.createElement("option");
            opt.value = opt.textContent = n;
            if (n === g.name) opt.selected = true;
            moveSel.appendChild(opt);
          });
          moveSel.addEventListener("change", () => movePerson(p, g.name, moveSel.value));

          const delBtn = document.createElement("button");
          delBtn.textContent = "Löschen";
          delBtn.textContent = "Löschen";
          delBtn.addEventListener("click", () => {
            if (confirm(`\"${p}\" wirklich löschen?`)) deletePerson(p);
          });

          delBtn.textContent = "Löschen";
          row.appendChild(name);
          // Wrap move+delete into actions container for nicer layout
          const actions = document.createElement("span");
          actions.className = "gm-chip-actions";
          actions.appendChild(moveSel);
          actions.appendChild(delBtn);
          row.appendChild(actions);
          section.appendChild(row);
        });
        }

        listWrap.appendChild(section);
      });

      gm.appendChild(listWrap);
    }

    function loadCalendar(data) {
      const container = document.getElementById("calendar");
      container.innerHTML = "";
      container.style.setProperty("--hour-width", hourWidth + "px");

      const hours = [...Array(24).keys()];
      const viewDateStr = data.date || new Date().toISOString().slice(0,10);
      const dayStart = new Date(viewDateStr + "T00:00");
      const dayEnd = new Date(viewDateStr + "T24:00");

      // Header row
      const header = document.createElement("div");
      header.className = "timeline";
      header.appendChild(document.createElement("div")); // empty top-left
      hours.forEach(h => {
        const div = document.createElement("div");
        div.className = "header";
        div.textContent = h.toString().padStart(2, "0") + ":00";
        header.appendChild(div);
      });
      container.appendChild(header);

      // Build rows
      function getRows() {
        const rows = [];
        data.groups.forEach(g => {
          if (g.name === 'Ungruppiert' && (!g.people || g.people.length === 0)) return;
          rows.push({ type: "group", name: g.name });
          if (!collapsedGroups.has(g.name)) {
            g.people.forEach(p => rows.push({ type: "person", name: p, group: g.name }));
          }
        });
        return rows;
      }

      const rows = getRows();

      rows.forEach(row => {
        const rowDiv = document.createElement("div");
        rowDiv.className = "timeline";

        const label = document.createElement("div");
        label.className = row.type === "group" ? "label group" : "label";
        // Normalize person label with bullet prefix
        label.textContent = row.type === "group" ? row.name : "• " + row.name;
        const groupNameForRow = row.type === "group" ? row.name : row.group;
        const gCol = getGroupColorByName(groupNameForRow);
        const rgb = hexToRgb(gCol);
        label.style.background = rgba(rgb, 0.1);
        label.style.borderLeft = "6px solid " + gCol;
        label.textContent = row.type === "group" ? row.name : "• " + row.name;
        rowDiv.appendChild(label);
        // Apply collapsible behavior and final text
        if (row.type === "group") {
          const isCollapsed = collapsedGroups.has(row.name);
          const caret = isCollapsed ? "▶" : "▼";
          label.textContent = `${caret} ${row.name}`;
          label.addEventListener('click', () => {
            if (collapsedGroups.has(row.name)) collapsedGroups.delete(row.name); else collapsedGroups.add(row.name);
            loadCalendar(tableData);
          });
        } else {
          label.textContent = "• " + row.name;
        }

        hours.forEach(() => {
          const cell = document.createElement("div");
          cell.className = "cell";
          // Tönung über gesamte Zeile entsprechend Gruppenfarbe
          const alpha = row.type === "group" ? 0.08 : 0.05;
          cell.style.background = rgba(rgb, alpha);
          rowDiv.appendChild(cell);
        });

        container.appendChild(rowDiv);

        // Place events
        data.events.forEach(ev => {
          const attendees = ev.attendees || [];
          const match =
            (row.type === "group" && attendees.includes(row.name)) ||
            (row.type === "person" && attendees.includes(row.name));
          if (!match) return;

          // Clip multi-day events to the current view day
          const evStart = new Date(ev.start);
          const evEnd = new Date(ev.end);
          const clipStart = new Date(Math.max(evStart.getTime(), dayStart.getTime()));
          const clipEnd = new Date(Math.min(evEnd.getTime(), dayEnd.getTime()));
          if (clipEnd <= clipStart) return; // no overlap with this day
          const startHour = clipStart.getHours() + clipStart.getMinutes() / 60;
          const endHour = clipEnd.getHours() + clipEnd.getMinutes() / 60;

          const eventDiv = document.createElement("div");
          eventDiv.className = "event";
          eventDiv.style.background = ev.color;
          eventDiv.style.left = (150 + startHour * hourWidth) + "px";
          eventDiv.style.width = ((endHour - startHour) * hourWidth) + "px";
          // Show title and optional location in the event bar
          let evText = ev.title || "(ohne Titel)";
          if (ev.location && ev.location.trim()) evText += " • " + ev.location.trim();
          // Force '@' separator for title/location
          evText = (ev.title || "(ohne Titel)") + ((ev.location && ev.location.trim()) ? " @ " + ev.location.trim() : "");
          eventDiv.textContent = evText;

          // Link the element to the event
          eventDiv.dataset.eventIndex = data.events.indexOf(ev);

          // Dragging
          makeDraggable(eventDiv);

          // Open editor on double click
          eventDiv.addEventListener('dblclick', (e) => {
            const idxOpen = parseInt(eventDiv.dataset.eventIndex, 10);
            if (!isNaN(idxOpen)) {
              // Defer to allow dblclick after any drag end
              setTimeout(() => {
                if (typeof openEvModal === 'function') openEvModal(idxOpen);
              }, 0);
            }
          });

          // Resizing
          const leftHandle = document.createElement("div");
          leftHandle.className = "resize-handle left";
          eventDiv.appendChild(leftHandle);
          makeResizable(leftHandle, "left", eventDiv);

          const rightHandle = document.createElement("div");
          rightHandle.className = "resize-handle right";
          eventDiv.appendChild(rightHandle);
          makeResizable(rightHandle, "right", eventDiv);

          rowDiv.appendChild(eventDiv);
        });
      });
    }

    function updateEvent(ev, leftPx, widthPx) {

  // Snap to nearest 5 minutes
  const snapMinutes = 30;
  const totalMinutes = Math.round(((leftPx-150) / hourWidth) * 60 / snapMinutes) * snapMinutes;
  const hour = Math.floor(totalMinutes / 60);
  const minute = totalMinutes % 60;

  const durationMinutes = Math.round((widthPx / hourWidth) * 60 / snapMinutes) * snapMinutes;
  const endTotalMinutes = totalMinutes + durationMinutes;
  const endHour = Math.floor(endTotalMinutes / 60);
  const endMinute = endTotalMinutes % 60;


  const dateStr = ev.start.split("T")[0];
  const newStart = new Date(dateStr + "T00:00");
  newStart.setHours(hour+2, minute, 0, 0); // +2 for timezone offset
  const newEnd = new Date(dateStr + "T00:00");
  newEnd.setHours(endHour+2, endMinute, 0, 0); // +2 for timezone offset
  ev.start = newStart.toISOString().slice(0,16);
  ev.end = newEnd.toISOString().slice(0,16);
  syncAllEventElements(ev);
}

    function syncAllEventElements(ev) {
      const idx = tableData.events.indexOf(ev);
      const elems = document.querySelectorAll(`.event[data-event-index='${idx}']`);
      const start = new Date(ev.start);
      const end = new Date(ev.end);
      const startHour = start.getHours() + start.getMinutes() / 60;
      const endHour = end.getHours() + end.getMinutes() / 60;
      elems.forEach(el => {
        el.style.left = (150 + startHour * hourWidth) + "px";
        el.style.width = ((endHour - startHour) * hourWidth) + "px";
      });
    }

    function makeDraggable(el) {
  let isDragging = false, startX, origLeft;
  const ev = tableData.events[el.dataset.eventIndex];

  el.addEventListener("mousedown", e => {
    if (e.target.classList.contains("resize-handle")) return; // ignore resize
    isDragging = true;
    startX = e.clientX;
    origLeft = parseFloat(el.style.left);
    e.preventDefault();
  });

  window.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    const newLeft = origLeft + dx;

    // Move all event elements visually
    const idx = tableData.events.indexOf(ev);
    const elems = document.querySelectorAll(`.event[data-event-index='${idx}']`);
    elems.forEach(elm => {
      elm.style.left = newLeft + "px";
    });
  });

  window.addEventListener("mouseup", e => {
    if (isDragging) {
        isDragging = false;
        // Use the new left position to update event data
        const idx = tableData.events.indexOf(ev);
        const elems = document.querySelectorAll(`.event[data-event-index='${idx}']`);
        // Use the left of the first element (they are all the same now)
        const leftPx = parseFloat(elems[0].style.left);
        const widthPx = parseFloat(elems[0].style.width);
        updateEvent(ev, leftPx, widthPx);
        
    }
  });
}

    function makeResizable(handle, side, el) {
      let isResizing = false, startX, origWidth, origLeft;
      const ev = tableData.events[el.dataset.eventIndex];
    
      handle.addEventListener("mousedown", e => {
        isResizing = true;
        startX = e.clientX;
        origWidth = parseFloat(el.style.width);
        origLeft = parseFloat(el.style.left);
        e.preventDefault();
        e.stopPropagation();
      });
    
      window.addEventListener("mousemove", e => {

        
        
        if (!isResizing) return;
        const dx = e.clientX - startX;
        if (side === "right") {
            newLeft = origLeft;
            newWidth = origWidth + dx;
        } else {
            newLeft = origLeft + dx;
            newWidth = origWidth - dx;
        }
        // Move all event elements visually
        const idx = tableData.events.indexOf(ev);
        const elems = document.querySelectorAll(`.event[data-event-index='${idx}']`);
        elems.forEach(elm => {
            elm.style.left = newLeft + "px";
            elm.style.width = newWidth + "px";
        });
      });
    
      window.addEventListener("mouseup", e => {
        if (isResizing) {
          isResizing = false;
          updateEvent(ev, parseFloat(el.style.left), parseFloat(el.style.width));
          syncAllEventElements(ev);
        }
      });
    }


    // File selection
    document.getElementById("fileInput").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          tableData = JSON.parse(evt.target.result);
          loadCalendar(tableData);
          document.getElementById("downloadBtn").disabled = false;
          document.getElementById("manageBtn").disabled = false;
          const neb = document.getElementById("newEventBtn");
          if (neb) neb.disabled = false;
          const nab = document.getElementById("noAttBtn");
          if (nab) nab.disabled = false;
          updateNoAttCount();
        } catch (err) {
          document.getElementById("calendar").textContent =
            "Invalid JSON file: " + err;
        }
      };
      reader.readAsText(file, "UTF-8");
    });

    // Zoom
    document.getElementById("zoomSlider").addEventListener("input", e => {
      hourWidth = parseInt(e.target.value);
      if (tableData) loadCalendar(tableData);
    });

    // Download JSON
    document.getElementById("downloadBtn").addEventListener("click", () => {
      const blob = new Blob([JSON.stringify(tableData, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "updated_calendar.json";
      a.click();
      URL.revokeObjectURL(url);
    });

    // Teilnehmer/Gruppen Modul öffnen/schließen
    const gmModal = document.getElementById("gmModal");
    const gmClose = document.getElementById("gmModalClose");
    const gmOpenBtn = document.getElementById("manageBtn");

    function openGmModal() {
      if (!tableData) return;
      renderGroupManager();
      gmModal.classList.add("open");
      gmModal.setAttribute("aria-hidden", "false");
      const gmBody = document.getElementById("gmModalBody");
      if (gmBody) gmBody.scrollTop = 0;
    }

    function closeGmModal() {
      gmModal.classList.remove("open");
      gmModal.setAttribute("aria-hidden", "true");
    }

    if (gmOpenBtn) gmOpenBtn.addEventListener("click", openGmModal);
    if (gmClose) gmClose.addEventListener("click", closeGmModal);
    if (gmModal) gmModal.addEventListener("click", (e) => {
      if (e.target === gmModal) closeGmModal();
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && gmModal.classList.contains("open")) closeGmModal();
    });

    // ---- Termin-Editor (Neu/Edit) ----
    const evModal = document.getElementById("evModal");
    const evClose = document.getElementById("evModalClose");
    const evBody = document.getElementById("evModalBody");
    const newEventBtn = document.getElementById("newEventBtn");
    const naModal = document.getElementById("naModal");
    const naClose = document.getElementById("naModalClose");
    const naBody = document.getElementById("naModalBody");
    const noAttBtn = document.getElementById("noAttBtn");

    function updateNoAttCount() {
      const btn = document.getElementById("noAttBtn");
      if (!btn || !tableData) return;
      const cnt = (tableData.events || []).filter(ev => !(Array.isArray(ev.attendees) && ev.attendees.length > 0)).length;
      btn.textContent = `Termine ohne Teilnehmer (${cnt})`;
    }

    function openEvModal(eventIndex = -1) {
      renderEventEditor(eventIndex);
      evModal.classList.add("open");
      evModal.setAttribute("aria-hidden", "false");
    }
    function closeEvModal() {
      evModal.classList.remove("open");
      evModal.setAttribute("aria-hidden", "true");
      // Wenn Liste der Termine ohne Teilnehmer offen ist, aktualisieren
      if (naModal && naModal.classList.contains("open")) renderNoAttList();
      updateNoAttCount();
    }
    if (evClose) evClose.addEventListener("click", closeEvModal);
    if (evModal) evModal.addEventListener("click", (e) => { if (e.target === evModal) closeEvModal(); });
    if (newEventBtn) newEventBtn.addEventListener("click", () => openEvModal(-1));

    // ---- Termine ohne Teilnehmer (Liste) ----
    function openNaModal() {
      renderNoAttList();
      naModal.classList.add("open");
      naModal.setAttribute("aria-hidden", "false");
    }
    function closeNaModal() {
      naModal.classList.remove("open");
      naModal.setAttribute("aria-hidden", "true");
    }
    function renderNoAttList() {
      naBody.innerHTML = "";
      const list = document.createElement("div");
      list.className = "na-list";
      // Header
      const hTitle = document.createElement("div"); hTitle.className = "na-head"; hTitle.textContent = "Titel";
      const hStart = document.createElement("div"); hStart.className = "na-head"; hStart.textContent = "Start";
      const hEnd = document.createElement("div"); hEnd.className = "na-head"; hEnd.textContent = "Ende";
      const hAct = document.createElement("div"); hAct.className = "na-head"; hAct.textContent = "Aktionen";
      list.appendChild(hTitle); list.appendChild(hStart); list.appendChild(hEnd); list.appendChild(hAct);

      let count = 0;
      (tableData?.events || []).forEach((ev, idx) => {
        const atts = ev.attendees;
        if (Array.isArray(atts) && atts.length > 0) return;
        // row container (display: contents)
        const row = document.createElement("div"); row.className = "na-row";
        const t = document.createElement("div");
        const pill = document.createElement("span"); pill.className = "na-pill"; pill.style.background = ev.color || "#9e9e9e";
        t.appendChild(pill);
        t.appendChild(document.createTextNode((ev.title||"(ohne Titel)")));
        const s = document.createElement("div"); s.textContent = ev.start || "";
        const e = document.createElement("div"); e.textContent = ev.end || "";
        const acts = document.createElement("div");
        const edit = document.createElement("button"); edit.textContent = "Bearbeiten"; edit.addEventListener("click", () => { closeNaModal(); openEvModal(idx); });
        const del = document.createElement("button"); del.textContent = "Löschen"; del.addEventListener("click", () => { if (confirm("Termin wirklich löschen?")) { tableData.events.splice(idx,1); loadCalendar(tableData); renderNoAttList(); updateNoAttCount(); }});
        acts.appendChild(edit); acts.appendChild(del);
        list.appendChild(t); list.appendChild(s); list.appendChild(e); list.appendChild(acts);
        count++;
      });
      if (count === 0) {
        const empty = document.createElement("div"); empty.style.gridColumn = "1 / -1"; empty.style.color = "#666"; empty.textContent = "Keine Termine ohne Teilnehmer gefunden.";
        list.appendChild(empty);
      }
      naBody.appendChild(list);
    }
    if (noAttBtn) noAttBtn.addEventListener("click", openNaModal);
    if (naClose) naClose.addEventListener("click", closeNaModal);
    if (naModal) naModal.addEventListener("click", (e) => { if (e.target === naModal) closeNaModal(); });

    function renderEventEditor(eventIndex) {
      const isNew = eventIndex === -1;
      const ev = isNew ? { title: "", start: "", end: "", color: "", attendees: [], notes: "", location: "" } : { ...tableData.events[eventIndex] };
      const todayStr = new Date().toISOString().slice(0,10);
      const baseDate = (ev.start && ev.start.includes('T')) ? ev.start.split('T')[0] : (tableData?.date || todayStr);
      const startVal = ev.start && ev.start.includes('T') ? ev.start.split('T')[1] : "09:00";
      const endVal = ev.end && ev.end.includes('T') ? ev.end.split('T')[1] : "10:00";
      const startDateVal = ev.start && ev.start.includes('T') ? ev.start.split('T')[0] : baseDate;
      const endDateVal = ev.end && ev.end.includes('T') ? ev.end.split('T')[0] : startDateVal;

      evBody.innerHTML = "";
      const form = document.createElement("div");
      form.style.display = "grid";
      form.style.gridTemplateColumns = "1fr 1fr";
      form.style.gap = "10px";

      const titleInput = document.createElement("input");
      titleInput.type = "text"; titleInput.placeholder = "Titel"; titleInput.value = ev.title || ""; titleInput.style.gridColumn = "1 / span 2";
      form.appendChild(titleInput);

      // Ort
      const locationInput = document.createElement("input");
      locationInput.type = "text"; locationInput.placeholder = "Ort"; locationInput.value = ev.location || ""; locationInput.style.gridColumn = "1 / span 2";
      form.appendChild(locationInput);

      // Beginn/Ende kompakt
      const dtWrap = document.createElement("div");
      dtWrap.className = "ev-dt";
      // Beginn
      const startBlock = document.createElement("div"); startBlock.className = "ev-block";
      const startHead = document.createElement("div"); startHead.className = "ev-head"; startHead.textContent = "Beginn";
      const startDate = document.createElement("input"); startDate.type = "date"; startDate.value = startDateVal;
      const startTime = document.createElement("input"); startTime.type = "time"; startTime.value = startVal;
      startBlock.appendChild(startHead); startBlock.appendChild(startDate); startBlock.appendChild(startTime);
      dtWrap.appendChild(startBlock);
      // Ende
      const endBlock = document.createElement("div"); endBlock.className = "ev-block";
      const endHead = document.createElement("div"); endHead.className = "ev-head"; endHead.textContent = "Ende";
      const endDate = document.createElement("input"); endDate.type = "date"; endDate.value = endDateVal;
      const endTime = document.createElement("input"); endTime.type = "time"; endTime.value = endVal;
      endBlock.appendChild(endHead); endBlock.appendChild(endDate); endBlock.appendChild(endTime);
      dtWrap.appendChild(endBlock);
      form.appendChild(dtWrap);

      const notes = document.createElement("textarea"); notes.placeholder = "Notizen"; notes.value = ev.notes || ""; notes.style.gridColumn = "1 / span 2"; notes.rows = 3; form.appendChild(notes);

      // Color picker for event color
      let userChangedColor = false;
      const colorWrap = document.createElement("div");
      const colorLbl = document.createElement("label"); colorLbl.textContent = "Farbe";
      const colorInput = document.createElement("input"); colorInput.type = "color";
      let initialColor = ev.color || "#4caf50";
      // If existing attendees include a group, suggest its color
      (tableData.groups||[]).some(g => {
        if ((ev.attendees||[]).includes(g.name) && !ev.color) { initialColor = ensureGroupColor(g); return true; }
        return false;
      });
      colorInput.value = initialColor;
      colorInput.addEventListener("input", () => { userChangedColor = true; });
      colorWrap.appendChild(colorLbl); colorWrap.appendChild(colorInput);
      form.appendChild(colorWrap);

      const groupsBox = document.createElement("div"); groupsBox.style.gridColumn = "1 / span 2";
      const groupsTitle = document.createElement("div"); groupsTitle.textContent = "Gruppen"; groupsTitle.style.fontWeight = "bold"; groupsBox.appendChild(groupsTitle);
      const groupsWrap = document.createElement("div"); groupsWrap.style.display = "flex"; groupsWrap.style.flexWrap = "wrap"; groupsWrap.style.gap = "10px";
      tableData.groups.forEach((g, i) => {
        const wrap = document.createElement("label"); wrap.style.display = "inline-flex"; wrap.style.alignItems = "center"; wrap.style.gap = "6px";
        const chk = document.createElement("input"); chk.type = "checkbox"; chk.value = g.name; chk.checked = (ev.attendees||[]).includes(g.name);
        const swatch = document.createElement("span"); swatch.style.display = "inline-block"; swatch.style.width = "10px"; swatch.style.height = "10px"; swatch.style.border = "1px solid #ccc"; swatch.style.background = ensureGroupColor(g, i);
        const txt = document.createElement("span"); txt.textContent = g.name;
        wrap.appendChild(chk); wrap.appendChild(swatch); wrap.appendChild(txt);
        groupsWrap.appendChild(wrap);
      });
      // If user hasn't chosen a color manually, adapt to first selected group
      function syncColorFromSelection() {
        if (userChangedColor) return;
        const firstChecked = Array.from(groupsWrap.querySelectorAll('input[type="checkbox"]')).find(c => c.checked);
        if (firstChecked) { colorInput.value = getGroupColorByName(firstChecked.value); }
      }
      groupsWrap.addEventListener('change', syncColorFromSelection);
      groupsBox.appendChild(groupsWrap); form.appendChild(groupsBox);

      const autoMembersWrap = document.createElement("label"); autoMembersWrap.style.gridColumn = "1 / span 2";
      const autoMembers = document.createElement("input"); autoMembers.type = "checkbox"; autoMembers.checked = true; autoMembersWrap.appendChild(autoMembers);
      autoMembersWrap.appendChild(document.createTextNode(" Mitglieder ausgewählter Gruppen übernehmen"));
      form.appendChild(autoMembersWrap);

      const peopleBox = document.createElement("div"); peopleBox.style.gridColumn = "1 / span 2";
      const peopleTitle = document.createElement("div"); peopleTitle.textContent = "Teilnehmer"; peopleTitle.style.fontWeight = "bold"; peopleBox.appendChild(peopleTitle);
      tableData.groups.forEach((g) => {
        const gHead = document.createElement("div"); gHead.textContent = g.name; gHead.style.marginTop = "6px"; gHead.style.fontSize = "12px"; gHead.style.color = "#555"; peopleBox.appendChild(gHead);
        const pWrap = document.createElement("div"); pWrap.style.display = "flex"; pWrap.style.flexWrap = "wrap"; pWrap.style.gap = "10px";
        (g.people||[]).forEach((p) => {
          const wrap = document.createElement("label"); wrap.style.display = "inline-flex"; wrap.style.alignItems = "center"; wrap.style.gap = "6px";
          const chk = document.createElement("input"); chk.type = "checkbox"; chk.value = p; chk.checked = (ev.attendees||[]).includes(p);
          const bullet = document.createElement("span"); bullet.textContent = "•"; bullet.style.color = ensureGroupColor(g);
          const txt = document.createElement("span"); txt.textContent = p;
          wrap.appendChild(chk); wrap.appendChild(bullet); wrap.appendChild(txt);
          pWrap.appendChild(wrap);
        });
        peopleBox.appendChild(pWrap);
      });
      form.appendChild(peopleBox);

      const actions = document.createElement("div"); actions.style.gridColumn = "1 / span 2"; actions.style.display = "flex"; actions.style.gap = "8px"; actions.style.justifyContent = "flex-end";
      const saveBtn = document.createElement("button"); saveBtn.textContent = isNew ? "Erstellen" : "Speichern";
      const cancelBtn = document.createElement("button"); cancelBtn.textContent = "Abbrechen";
      const delBtn = !isNew ? document.createElement("button") : null;
      if (delBtn) { delBtn.textContent = "Löschen"; delBtn.style.marginRight = "auto"; actions.appendChild(delBtn); }
      actions.appendChild(cancelBtn); actions.appendChild(saveBtn);
      form.appendChild(actions);

      if (delBtn) delBtn.addEventListener("click", () => {
        if (confirm("Termin wirklich löschen?")) {
          tableData.events.splice(eventIndex, 1);
          loadCalendar(tableData);
          updateNoAttCount();
          closeEvModal();
        }
      });
      cancelBtn.addEventListener("click", (e) => { e.preventDefault(); closeEvModal(); });
      saveBtn.addEventListener("click", (e) => {
        e.preventDefault();
        const sd = startDate.value; const ed = endDate.value;
        const st = startTime.value; const et = endTime.value;
        if (!sd || !st || !ed || !et) { alert("Bitte Start- und Enddatum/-zeit angeben."); return; }
        const startIso = `${sd}T${st}`; const endIso = `${ed}T${et}`;
        if (new Date(startIso) >= new Date(endIso)) { alert("Ende muss nach dem Start liegen."); return; }
        const sels = [];
        groupsWrap.querySelectorAll('input[type="checkbox"]').forEach(chk => { if (chk.checked) sels.push(chk.value); });
        peopleBox.querySelectorAll('input[type="checkbox"]').forEach(chk => { if (chk.checked) sels.push(chk.value); });
        if (autoMembers.checked) {
          (tableData.groups||[]).forEach(g => { if (sels.includes(g.name)) { (g.people||[]).forEach(p => { if (!sels.includes(p)) sels.push(p); }); } });
        }
        const color = colorInput.value || "#4caf50";
        const newEv = {
          title: (titleInput.value||"").trim() || "(ohne Titel)",
          start: startIso,
          end: endIso,
          color,
          attendees: sels,
          notes: (notes.value||""),
          location: (locationInput.value||"").trim()
        };
      if (isNew) tableData.events.push(newEv); else tableData.events[eventIndex] = newEv;
      loadCalendar(tableData);
      updateNoAttCount();
      closeEvModal();
    });

      evBody.appendChild(form);
    }
  </script>
</body>
</html>
