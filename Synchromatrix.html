<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Horizontal Calendar</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    input[type="file"], input[type="range"], button { margin-bottom: 10px; }
    #calendarWrapper {
      overflow-x: auto;
      border: 1px solid #ccc;
    }
    .timeline {
      display: grid;
      grid-template-columns: 150px repeat(24, var(--hour-width, 60px));
      min-width: calc(150px + 24 * var(--hour-width, 60px));
      border-bottom: 1px solid #ccc;
      position: relative;
    }
    .header {
      font-weight: bold;
      text-align: center;
      border-right: 1px solid #ccc;
      padding: 2px;
    }
    .label {
      border-right: 1px solid #ccc;
      padding: 2px;
      background: #f0f0f0;
    }
    .cell {
      border: 1px solid #eee;
      height: 40px;
      position: relative;
    }
    .event {
      position: absolute;
      top: 4px;
      bottom: 4px;
      border-radius: 4px;
      color: white;
      font-size: 12px;
      padding: 2px 4px;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: grab;
    }
    .event:active { cursor: grabbing; }
    .resize-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 6px;
      cursor: ew-resize;
    }
    .resize-handle.left { left: 0; }
    .resize-handle.right { right: 0; }

    /* Modal styles for Teilnehmer-Verwaltung */
    .modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.45); z-index: 1000; }
    .modal.open { display: flex; }
    .modal .dialog { background: #fff; width: min(900px, 95vw); max-height: 90vh; border-radius: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.25); display: flex; flex-direction: column; overflow: hidden; }
    .modal .dialog header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #eee; background: #fafafa; }
    .modal .dialog header h3 { margin: 0; font-size: 16px; }
    .modal .dialog header button { border: none; background: transparent; font-size: 22px; line-height: 1; cursor: pointer; padding: 4px 8px; }
    .modal .dialog .body { padding: 12px 16px; overflow: auto; }
    .gm-toolbar { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
    .gm-section { padding: 6px 0; border-top: 1px solid #eee; }
    .gm-row { display: flex; align-items: center; gap: 8px; padding: 2px 0; }
    .gm-name { min-width: 160px; }
    .gm-header { display: flex; align-items: center; justify-content: space-between; margin: 2px 0 6px; }
    .gm-header .gm-actions { display: flex; gap: 6px; }
  </style>
</head>
<body>
  <h1>Interactive Horizontal Calendar</h1>
  <p>
    <label for="fileInput">Select JSON file:</label>
    <input type="file" id="fileInput" accept=".json">
    <button id="downloadBtn" disabled>Download Updated JSON</button>
    <button id="manageBtn" disabled>Teilnehmer und Gruppenverwaltung</button>
  </p>
  <p>
    Zoom: <input type="range" id="zoomSlider" min="30" max="200" value="60">
  </p>
  <!-- Teilnehmer-Verwaltung Modal -->
  <div id="gmModal" class="modal" aria-hidden="true">
    <div class="dialog" role="dialog" aria-modal="true" aria-labelledby="gmModalTitle">
      <header>
        <h3 id="gmModalTitle">Teilnehmer-Verwaltung</h3>
        <button id="gmModalClose" aria-label="Schließen">×</button>
      </header>
      <div id="gmModalBody" class="body"></div>
    </div>
  </div>
  <div id="calendarWrapper">
    <div id="calendar"></div>
  </div>

  <script>
    let tableData;
    let hourWidth = 60; // px per hour

    // ---- Farben für Gruppen ----
    const GROUP_COLOR_PALETTE = [
      "#64b5f6", "#81c784", "#ffd54f", "#ba68c8",
      "#4db6ac", "#ff8a65", "#90a4ae", "#e57373"
    ];
    function hexToRgb(hex) {
      if (!hex) return { r: 153, g: 153, b: 153 };
      let h = hex.replace('#','').trim();
      if (h.length === 3) h = h.split('').map(c => c + c).join('');
      const int = parseInt(h, 16);
      return { r: (int >> 16) & 255, g: (int >> 8) & 255, b: int & 255 };
    }
    function rgba(rgb, a) {
      const { r, g, b } = rgb || { r: 153, g: 153, b: 153 };
      return `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    function findGroupByName(name) {
      return (tableData?.groups || []).find(g => g.name === name);
    }
    function ensureGroupColor(g, idx = 0) {
      if (!g) return '#999999';
      if (!g.color) {
        // deterministisch: Verwende Index in Liste für Farbwahl
        const i = Math.max(0, (idx || tableData.groups.indexOf(g))) % GROUP_COLOR_PALETTE.length;
        g.color = GROUP_COLOR_PALETTE[i];
      }
      return g.color;
    }
    function getGroupColorByName(name) {
      if (name === 'Ungruppiert') return '#9e9e9e';
      const g = findGroupByName(name);
      return ensureGroupColor(g);
    }

    // ---- Teilnehmer-Verwaltung (Gruppen & Personen) ----
    function renderGroupManager() {
      const gm = document.getElementById("gmModalBody");
      if (!tableData || !Array.isArray(tableData.groups)) {
        gm.innerHTML = "";
        return;
      }

      // Helpers
      const groupNames = () => tableData.groups.map(g => g.name);
      const findGroup = (name) => tableData.groups.find(g => g.name === name);
      const personExists = (name) => tableData.groups.some(g => (g.people||[]).includes(name));

      const groupExists = (name) => {
        if (!name) return false;
        const n = String(name).trim().toLowerCase();
        return groupNames().some(g => g.toLowerCase() === n);
      };

      function ensureUngrouped() {
        let u = findGroup("Ungruppiert");
        if (!u) {
          u = { name: "Ungruppiert", people: [] };
          tableData.groups.push(u);
        }
        if (!Array.isArray(u.people)) u.people = [];
        return u;
      }

      function addGroup(name) {
        const n = (name || "").trim();
        if (!n) { alert("Gruppenname darf nicht leer sein."); return; }
        if (groupExists(n)) { alert("Gruppe existiert bereits."); return; }
        const idx = tableData.groups.length;
        const color = GROUP_COLOR_PALETTE[idx % GROUP_COLOR_PALETTE.length];
        tableData.groups.push({ name: n, people: [], color });
        loadCalendar(tableData);
        renderGroupManager();
      }

      function deleteGroup(name) {
        if (name === "Ungruppiert") { alert("Die Gruppe 'Ungruppiert' kann nicht gelöscht werden."); return; }
        const g = findGroup(name);
        if (!g) return;
        if (!confirm(`Gruppe "${name}" löschen? Mitglieder werden nach 'Ungruppiert' verschoben.`)) return;
        const fallback = ensureUngrouped();
        (g.people || []).forEach(p => {
          if (!fallback.people.includes(p)) fallback.people.push(p);
        });
        // Entferne Gruppenname aus allen Events
        (tableData.events || []).forEach(ev => {
          if (Array.isArray(ev.attendees)) {
            ev.attendees = ev.attendees.filter(a => a !== name);
          }
        });
        // Entferne Gruppe
        tableData.groups = tableData.groups.filter(gr => gr.name !== name);
        loadCalendar(tableData);
        renderGroupManager();
      }

      function addPersonToGroup(name, groupName) {
        const n = (name || "").trim();
        if (!n) { alert("Name darf nicht leer sein."); return; }
        if (!groupNames().includes(groupName)) { alert("Gruppe nicht gefunden."); return; }
        if (personExists(n)) { alert("Teilnehmername bereits vorhanden."); return; }
        const g = findGroup(groupName);
        if (!Array.isArray(g.people)) g.people = [];
        g.people.push(n);
        loadCalendar(tableData);
        renderGroupManager();
      }

      function movePerson(name, fromGroup, toGroup) {
        if (fromGroup === toGroup) return;
        const src = findGroup(fromGroup);
        const dst = findGroup(toGroup);
        if (!src || !dst) return;
        src.people = (src.people||[]).filter(p => p !== name);
        if (!Array.isArray(dst.people)) dst.people = [];
        if (dst.people.includes(name)) { alert("Zielgruppe enthält den Namen bereits."); return; }
        dst.people.push(name);
        loadCalendar(tableData);
        renderGroupManager();
      }

      function deletePerson(name) {
        // Entferne aus allen Gruppen
        tableData.groups.forEach(g => {
          g.people = (g.people||[]).filter(p => p !== name);
        });
        // Entferne aus allen Events
        (tableData.events||[]).forEach(ev => {
          if (Array.isArray(ev.attendees)) {
            ev.attendees = ev.attendees.filter(a => a !== name);
          }
        });
        loadCalendar(tableData);
        renderGroupManager();
      }

      // Aufbau UI
      gm.innerHTML = "";

      const addWrap = document.createElement("div");
      addWrap.className = "gm-toolbar";

      const groupSelect = document.createElement("select");
      groupSelect.id = "gmAddGroup";
      groupNames().forEach(n => {
        const opt = document.createElement("option");
        opt.value = opt.textContent = n;
        groupSelect.appendChild(opt);
      });

      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.placeholder = "Name des Teilnehmers";
      nameInput.id = "gmAddName";

      const addBtn = document.createElement("button");
      addBtn.textContent = "Hinzufügen";
      addBtn.addEventListener("click", () => addPersonToGroup(nameInput.value, groupSelect.value));
      addBtn.textContent = "Hinzufügen";

      addWrap.appendChild(groupSelect);
      addWrap.appendChild(nameInput);
      addWrap.appendChild(addBtn);

      // Gruppe hinzufügen
      const gNameInput = document.createElement("input");
      gNameInput.type = "text";
      gNameInput.placeholder = "Gruppenname";
      gNameInput.id = "gmGroupName";

      const gAddBtn = document.createElement("button");
      gAddBtn.textContent = "Gruppe hinzufügen";
      gAddBtn.addEventListener("click", () => addGroup(gNameInput.value));

      addWrap.appendChild(gNameInput);
      addWrap.appendChild(gAddBtn);

      gm.appendChild(addWrap);

      const listWrap = document.createElement("div");
      listWrap.style.marginTop = "10px";

      tableData.groups.forEach(g => {
        const section = document.createElement("div");
        section.style.padding = "6px 0";
        section.style.borderTop = "1px solid #eee";

        const header = document.createElement("div");
        header.style.fontWeight = "bold";
        header.textContent = `${g.name} (${(g.people||[]).length})`;
        section.appendChild(header);
        // Header-Aktionen (Gruppe löschen)
        header.style.display = "flex";
        header.style.alignItems = "center";
        header.style.justifyContent = "space-between";
        const hActions = document.createElement("div");
        // Farbwähler
        const colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.value = ensureGroupColor(g);
        colorInput.title = "Gruppenfarbe";
        colorInput.addEventListener("input", () => {
          g.color = colorInput.value;
          loadCalendar(tableData);
          renderGroupManager();
        });
        hActions.appendChild(colorInput);
        if (g.name !== "Ungruppiert") {
          const delGroupBtn = document.createElement("button");
          delGroupBtn.textContent = "Gruppe löschen";
          delGroupBtn.addEventListener("click", () => deleteGroup(g.name));
          hActions.appendChild(delGroupBtn);
        }
        header.appendChild(hActions);

        (g.people||[]).forEach(p => {
          const row = document.createElement("div");
          row.style.display = "flex";
          row.style.alignItems = "center";
          row.style.gap = "8px";
          row.style.padding = "2px 0";

          const name = document.createElement("span");
          name.textContent = p;
          name.style.minWidth = "160px";

          const moveSel = document.createElement("select");
          groupNames().forEach(n => {
            const opt = document.createElement("option");
            opt.value = opt.textContent = n;
            if (n === g.name) opt.selected = true;
            moveSel.appendChild(opt);
          });
          moveSel.addEventListener("change", () => movePerson(p, g.name, moveSel.value));

          const delBtn = document.createElement("button");
          delBtn.textContent = "Löschen";
          delBtn.textContent = "Löschen";
          delBtn.addEventListener("click", () => {
            if (confirm(`\"${p}\" wirklich löschen?`)) deletePerson(p);
          });

          delBtn.textContent = "Löschen";
          row.appendChild(name);
          row.appendChild(moveSel);
          row.appendChild(delBtn);
          section.appendChild(row);
        });

        listWrap.appendChild(section);
      });

      gm.appendChild(listWrap);
    }

    function loadCalendar(data) {
      const container = document.getElementById("calendar");
      container.innerHTML = "";
      container.style.setProperty("--hour-width", hourWidth + "px");

      const hours = [...Array(24).keys()];

      // Header row
      const header = document.createElement("div");
      header.className = "timeline";
      header.appendChild(document.createElement("div")); // empty top-left
      hours.forEach(h => {
        const div = document.createElement("div");
        div.className = "header";
        div.textContent = h.toString().padStart(2, "0") + ":00";
        header.appendChild(div);
      });
      container.appendChild(header);

      // Build rows
      function getRows() {
        const rows = [];
        data.groups.forEach(g => {
          rows.push({ type: "group", name: g.name });
          g.people.forEach(p => rows.push({ type: "person", name: p, group: g.name }));
        });
        return rows;
      }

      const rows = getRows();

      rows.forEach(row => {
        const rowDiv = document.createElement("div");
        rowDiv.className = "timeline";

        const label = document.createElement("div");
        label.className = "label";
        label.textContent = row.type === "group" ? row.name : "↳ " + row.name;
        rowDiv.appendChild(label);

        hours.forEach(() => {
          const cell = document.createElement("div");
          cell.className = "cell";
          rowDiv.appendChild(cell);
        });

        container.appendChild(rowDiv);

        // Place events
        data.events.forEach(ev => {
          const attendees = ev.attendees || [];
          const match =
            (row.type === "group" && attendees.includes(row.name)) ||
            (row.type === "person" && attendees.includes(row.name));
          if (!match) return;

          const start = new Date(ev.start);
          const end = new Date(ev.end);
          const startHour = start.getHours() + start.getMinutes() / 60;
          const endHour = end.getHours() + end.getMinutes() / 60;

          const eventDiv = document.createElement("div");
          eventDiv.className = "event";
          eventDiv.style.background = ev.color;
          eventDiv.style.left = (150 + startHour * hourWidth) + "px";
          eventDiv.style.width = ((endHour - startHour) * hourWidth) + "px";
          eventDiv.textContent = ev.title;

          // Link the element to the event
          eventDiv.dataset.eventIndex = data.events.indexOf(ev);

          // Dragging
          makeDraggable(eventDiv);

          // Resizing
          const leftHandle = document.createElement("div");
          leftHandle.className = "resize-handle left";
          eventDiv.appendChild(leftHandle);
          makeResizable(leftHandle, "left", eventDiv);

          const rightHandle = document.createElement("div");
          rightHandle.className = "resize-handle right";
          eventDiv.appendChild(rightHandle);
          makeResizable(rightHandle, "right", eventDiv);

          rowDiv.appendChild(eventDiv);
        });
      });
    }

    function updateEvent(ev, leftPx, widthPx) {

  // Snap to nearest 5 minutes
  const snapMinutes = 30;
  const totalMinutes = Math.round(((leftPx-150) / hourWidth) * 60 / snapMinutes) * snapMinutes;
  const hour = Math.floor(totalMinutes / 60);
  const minute = totalMinutes % 60;

  const durationMinutes = Math.round((widthPx / hourWidth) * 60 / snapMinutes) * snapMinutes;
  const endTotalMinutes = totalMinutes + durationMinutes;
  const endHour = Math.floor(endTotalMinutes / 60);
  const endMinute = endTotalMinutes % 60;


  const dateStr = ev.start.split("T")[0];
  const newStart = new Date(dateStr + "T00:00");
  newStart.setHours(hour+2, minute, 0, 0); // +2 for timezone offset
  const newEnd = new Date(dateStr + "T00:00");
  newEnd.setHours(endHour+2, endMinute, 0, 0); // +2 for timezone offset
  ev.start = newStart.toISOString().slice(0,16);
  ev.end = newEnd.toISOString().slice(0,16);
  syncAllEventElements(ev);
}

    function syncAllEventElements(ev) {
      const idx = tableData.events.indexOf(ev);
      const elems = document.querySelectorAll(`.event[data-event-index='${idx}']`);
      const start = new Date(ev.start);
      const end = new Date(ev.end);
      const startHour = start.getHours() + start.getMinutes() / 60;
      const endHour = end.getHours() + end.getMinutes() / 60;
      elems.forEach(el => {
        el.style.left = (150 + startHour * hourWidth) + "px";
        el.style.width = ((endHour - startHour) * hourWidth) + "px";
      });
    }

    function makeDraggable(el) {
  let isDragging = false, startX, origLeft;
  const ev = tableData.events[el.dataset.eventIndex];

  el.addEventListener("mousedown", e => {
    if (e.target.classList.contains("resize-handle")) return; // ignore resize
    isDragging = true;
    startX = e.clientX;
    origLeft = parseFloat(el.style.left);
    e.preventDefault();
  });

  window.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    const newLeft = origLeft + dx;

    // Move all event elements visually
    const idx = tableData.events.indexOf(ev);
    const elems = document.querySelectorAll(`.event[data-event-index='${idx}']`);
    elems.forEach(elm => {
      elm.style.left = newLeft + "px";
    });
  });

  window.addEventListener("mouseup", e => {
    if (isDragging) {
        isDragging = false;
        // Use the new left position to update event data
        const idx = tableData.events.indexOf(ev);
        const elems = document.querySelectorAll(`.event[data-event-index='${idx}']`);
        // Use the left of the first element (they are all the same now)
        const leftPx = parseFloat(elems[0].style.left);
        const widthPx = parseFloat(elems[0].style.width);
        updateEvent(ev, leftPx, widthPx);
        
    }
  });
}

    function makeResizable(handle, side, el) {
      let isResizing = false, startX, origWidth, origLeft;
      const ev = tableData.events[el.dataset.eventIndex];
    
      handle.addEventListener("mousedown", e => {
        isResizing = true;
        startX = e.clientX;
        origWidth = parseFloat(el.style.width);
        origLeft = parseFloat(el.style.left);
        e.preventDefault();
        e.stopPropagation();
      });
    
      window.addEventListener("mousemove", e => {

        
        
        if (!isResizing) return;
        const dx = e.clientX - startX;
        if (side === "right") {
            newLeft = origLeft;
            newWidth = origWidth + dx;
        } else {
            newLeft = origLeft + dx;
            newWidth = origWidth - dx;
        }
        // Move all event elements visually
        const idx = tableData.events.indexOf(ev);
        const elems = document.querySelectorAll(`.event[data-event-index='${idx}']`);
        elems.forEach(elm => {
            elm.style.left = newLeft + "px";
            elm.style.width = newWidth + "px";
        });
      });
    
      window.addEventListener("mouseup", e => {
        if (isResizing) {
          isResizing = false;
          updateEvent(ev, parseFloat(el.style.left), parseFloat(el.style.width));
          syncAllEventElements(ev);
        }
      });
    }


    // File selection
    document.getElementById("fileInput").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          tableData = JSON.parse(evt.target.result);
          loadCalendar(tableData);
          document.getElementById("downloadBtn").disabled = false;
          document.getElementById("manageBtn").disabled = false;
        } catch (err) {
          document.getElementById("calendar").textContent =
            "Invalid JSON file: " + err;
        }
      };
      reader.readAsText(file, "UTF-8");
    });

    // Zoom
    document.getElementById("zoomSlider").addEventListener("input", e => {
      hourWidth = parseInt(e.target.value);
      if (tableData) loadCalendar(tableData);
    });

    // Download JSON
    document.getElementById("downloadBtn").addEventListener("click", () => {
      const blob = new Blob([JSON.stringify(tableData, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "updated_calendar.json";
      a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
